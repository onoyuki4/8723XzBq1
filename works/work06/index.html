<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>작품 뷰어</title>
  <style>
    /* CSS 내용은 이전과 동일하므로 생략 */
    body { font-family: sans-serif; padding: 1rem; background: #fff; margin: 0; } body.fullscreen-active { overflow: hidden; } .info { text-align: center; margin-bottom: 1rem; } .info h2 { margin: 0.5rem 0; } .info .author { color: #555; font-size: 0.9em; margin-top: 0.2rem;} .images { display: flex; flex-direction: column; gap: 10px; align-items: center; } .images a { display: block; width: 90%; max-width: 300px; min-height: 150px; background-color: #eee; border-radius: 8px; overflow: hidden; } .images img { display: block; width: 100%; height: auto; box-shadow: 0 0 8px rgba(0,0,0,0.1); cursor: pointer; opacity: 0; transition: opacity 0.5s ease-in-out; } .images img.lazyloaded { opacity: 1; } #fullscreen-container { position: relative; } .counter-container { position: fixed; top: 10px; right: 10px; z-index: 10002; } .fancybox__counter { font-size: 16px; background: rgba(0, 0, 0, 0.6); color: #fff; padding: 4px 10px; border-radius: 12px; user-select: none; cursor: pointer; display: inline-block; } .fullscreen-container.jump-ui-active .counter-container { opacity: 0.2; pointer-events: none; } .fullscreen-viewer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; overflow: hidden; } .fullscreen-viewer.active { opacity: 1; visibility: visible; } .fullscreen-viewer img { max-width: 95%; max-height: 95%; object-fit: contain; cursor: grab; user-select: none; -webkit-user-drag: none; transition: opacity 0.2s ease-out; touch-action: none; transform-origin: center center; } .fullscreen-viewer img.dragging, .fullscreen-viewer img.panning { cursor: grabbing; } .page-jump-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 10001; cursor: pointer; } #page-jump-list { background-color: #333; color: #eee; padding: 10px 0; border-radius: 10px; max-height: 70vh; overflow-y: auto; display: flex; flex-direction: column; gap: 0px; cursor: default; width: 200px; scrollbar-width: thin; scrollbar-color: #666 #333; } #page-jump-list::-webkit-scrollbar { width: 6px; } #page-jump-list::-webkit-scrollbar-track { background: #333; } #page-jump-list::-webkit-scrollbar-thumb { background-color: #666; border-radius: 3px; } .page-jump-number { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; cursor: pointer; font-weight: normal; text-align: left; transition: background-color 0.2s ease; border-bottom: 1px solid #444; font-size: 16px; } .page-jump-number:last-child { border-bottom: none; } .page-jump-number:hover { background-color: #444; } .page-jump-number::after { content: ''; display: inline-block; width: 18px; height: 18px; border-radius: 50%; border: 2px solid #888; margin-left: 15px; position: relative; box-sizing: border-box; } .page-jump-number.current { font-weight: bold; } .page-jump-number.current::after { border-color: #eee; background-color: #eee; }
  </style>
</head>
<body>
  <div class="info"> <h2 id="work-title"></h2> <p class="author" id="work-author"></p> </div>
  <div class="images"></div>
  <div id="load-more-trigger" style="height: 50px;"></div>
  <div id="fullscreen-container"></div>

  <script src="config.js"></script>

  <script> // 메인 뷰어 스크립트 시작
    if (typeof workConfig === 'undefined' || !workConfig || !Array.isArray(workConfig.images)) { console.error("workConfig is not defined..."); document.body.innerHTML = '<p style="color: red; ...">...</p>'; throw new Error("workConfig is not defined..."); }

    const imageFiles = workConfig.images; const fullscreenContainer = document.getElementById('fullscreen-container'); const bodyElement = document.body; const imagesContainer = document.querySelector('.images'); const workTitleElement = document.getElementById('work-title'); const workAuthorElement = document.getElementById('work-author'); const loadMoreTrigger = document.getElementById('load-more-trigger');
    const itemsPerLoad = 10; let lastLoadedIndex = -1; let thumbnailObserver = null; let imageLazyLoadObserver = null;
    let currentIndex = 0; let isFullscreen = false; let fullscreenViewer = null; let viewerImage = null; let counterContainer = null; let counterElement = null; let pageJumpOverlay = null; let isDragging = false; let startX = 0, currentX = 0, clickStartX = 0, clickStartY = 0, dragStartTime = 0; let pointerDown = false, clickTimeoutId = null; const swipeThreshold = 50, clickMoveThreshold = 15, clickTimeThreshold = 250; const dragStartThreshold = 5, clickDebounceTime = 60; const preloadCache = new Set();
    let isPinching = false; let isPanning = false; let initialDistance = 0; let currentScale = 1; let translateX = 0, translateY = 0; let pinchCenterX = 0, pinchCenterY = 0; let panStartX = 0, panStartY = 0; let lastScale = 1, lastTranslateX = 0, lastTranslateY = 0; const minScale = 1, maxScale = 5;

    // --- 썸네일 생성/로딩 함수 ---
    function generateThumbnails(startIndex, count) { /* 내용 동일, 생략 */ const fragment = document.createDocumentFragment(); const endIndex = Math.min(startIndex + count, imageFiles.length); for (let index = startIndex; index < endIndex; index++) { if (index > lastLoadedIndex) { const filename = imageFiles[index]; if (!filename) continue; const link = document.createElement('a'); link.href = filename; link.dataset.index = index; const img = document.createElement('img'); img.dataset.src = filename; img.alt = `${workConfig.title || 'Image'} - Image ${index + 1}`; img.loading = 'lazy'; link.appendChild(img); fragment.appendChild(link); lastLoadedIndex = index; } } imagesContainer.appendChild(fragment); addViewerEventListeners(startIndex, endIndex); setupImageLazyLoadForRange(startIndex, endIndex); if (endIndex >= imageFiles.length && thumbnailObserver && loadMoreTrigger) { thumbnailObserver.unobserve(loadMoreTrigger); loadMoreTrigger.style.display = 'none'; } }
    function setupThumbnailObserver() { /* 내용 동일, 생략 */ const options = { root: null, rootMargin: '0px 0px 300px 0px', threshold: 0.01 }; thumbnailObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) generateThumbnails(lastLoadedIndex + 1, itemsPerLoad); }); }, options); if (loadMoreTrigger) thumbnailObserver.observe(loadMoreTrigger); else console.warn("Load more trigger element not found."); }
    function addViewerEventListeners(startIndex, endIndex) { /* 내용 동일, 생략 */ const links = imagesContainer.querySelectorAll(`a[data-index]:not([data-listener-added="true"])`); links.forEach(link => { const index = parseInt(link.dataset.index, 10); if (index >= startIndex && index < endIndex) { link.addEventListener('click', handleThumbnailClick); link.dataset.listenerAdded = 'true'; } }); }
    function handleThumbnailClick(event) { /* 내용 동일, 생략 */ event.preventDefault(); const index = parseInt(event.currentTarget.dataset.index, 10); if (!isNaN(index)) openFullscreen(index); else console.error("Invalid index on thumbnail click:", event.currentTarget); }
    function setupImageLazyLoadForRange(startIndex, endIndex) { /* 내용 동일, 생략 */ if (!imageLazyLoadObserver) { imageLazyLoadObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const lazyImage = entry.target; if (lazyImage.dataset.src) { lazyImage.src = lazyImage.dataset.src; lazyImage.classList.add('lazyloaded'); lazyImage.removeAttribute('data-src'); observer.unobserve(lazyImage); } } }); }, { rootMargin: '0px 0px 150px 0px' }); } const imagesToObserve = imagesContainer.querySelectorAll(`img[data-src]`); imagesToObserve.forEach(img => { const parentLink = img.closest('a'); if (parentLink && parentLink.dataset.index) { const index = parseInt(parentLink.dataset.index, 10); if (index >= startIndex && index < endIndex) imageLazyLoadObserver.observe(img); } }); }

    // --- 뷰어 공통 함수 ---
    function preloadImage(index) { /* 내용 동일, 생략 */ if (index < 0 || index >= imageFiles.length) return; const imageUrl = imageFiles[index]; if (!imageUrl || preloadCache.has(imageUrl)) return; const img = new Image(); img.src = imageUrl; preloadCache.add(imageUrl); }
    function updateCounter() { /* 내용 동일, 생략 */ if (counterElement) counterElement.innerText = `${currentIndex + 1} / ${imageFiles.length}`; }
    function showImage(index) { /* 내용 동일, 생략 */ if (!isFullscreen) return; if (index >= 0 && index < imageFiles.length) { currentIndex = index; const imageUrl = imageFiles[currentIndex]; if (!imageUrl) { console.error(`Image URL is invalid for index: ${index}`); return; } if (viewerImage) { currentScale = 1; translateX = 0; translateY = 0; lastScale = 1; lastTranslateX = 0; lastTranslateY = 0; isPinching = false; isPanning = false; applyTransform(); viewerImage.src = imageUrl; updateCounter(); preloadImage(currentIndex + 1); preloadImage(currentIndex - 1); } } else { console.warn(`Invalid index requested: ${index}`); } }
    function getDistance(p1, p2) { /* 내용 동일, 생략 */ const dx = p1.clientX - p2.clientX; const dy = p1.clientY - p2.clientY; return Math.sqrt(dx * dx + dy * dy); }
    function getMidpoint(p1, p2) { /* 내용 동일, 생략 */ return { x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 }; }

    // ▼▼▼ applyTransform 함수에 로그 추가 ▼▼▼
    function applyTransform() {
        if (viewerImage) {
            const { constrainedX, constrainedY } = constrainPanning(translateX, translateY, currentScale);
            // 값 변경 로그 (필요시 주석 해제)
            // if (translateX !== constrainedX || translateY !== constrainedY) {
            //     console.log(`[Constrain] X: ${translateX}=>${constrainedX}, Y: ${translateY}=>${constrainedY}`);
            // }
            translateX = constrainedX; translateY = constrainedY;
            lastTranslateX = translateX; lastTranslateY = translateY;
            const transformString = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
            console.log("[ApplyTransform] Setting transform:", transformString); // <--- Transform 적용 로그
            viewerImage.style.transform = transformString;
        }
    }
    // ▲▲▲ applyTransform 함수에 로그 추가 ▲▲▲

    function constrainPanning(newX, newY, scale) { /* 내용 동일, 생략 */ if (!viewerImage || scale <= 1) return { constrainedX: 0, constrainedY: 0 }; const naturalWidth = viewerImage.offsetWidth; const naturalHeight = viewerImage.offsetHeight; if (naturalWidth === 0 || naturalHeight === 0) return { constrainedX: 0, constrainedY: 0 }; const scaledWidth = naturalWidth * scale; const scaledHeight = naturalHeight * scale; const maxX = Math.max(0, (scaledWidth - window.innerWidth) / 2); const minX = -maxX; const maxY = Math.max(0, (scaledHeight - window.innerHeight) / 2); const minY = -maxY; const constrainedX = Math.max(minX, Math.min(maxX, newX)); const constrainedY = Math.max(minY, Math.min(maxY, newY)); return { constrainedX, constrainedY }; }
    function togglePageJumpUI() { /* 내용 동일, 생략 */ if (!isFullscreen) return; if (pageJumpOverlay) { removePageJumpUI(); return; } pageJumpOverlay = document.createElement('div'); pageJumpOverlay.className = 'page-jump-overlay'; pageJumpOverlay.addEventListener('click', handleOverlayClick); createPageJumpList(pageJumpOverlay); fullscreenContainer.appendChild(pageJumpOverlay); fullscreenContainer.classList.add('jump-ui-active'); const currentButton = pageJumpOverlay.querySelector(`.page-jump-number.current`); if (currentButton) currentButton.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
    function handleOverlayClick(event) { /* 내용 동일, 생략 */ if (event.target === pageJumpOverlay) removePageJumpUI(); }
    function createPageJumpList(overlay) { /* 내용 동일, 생략 */ const listContainer = document.createElement('div'); listContainer.id = 'page-jump-list'; listContainer.addEventListener('click', (e) => e.stopPropagation()); for (let i = 1; i <= imageFiles.length; i++) { const pageNumElement = document.createElement('div'); pageNumElement.className = 'page-jump-number'; pageNumElement.innerHTML = `<span>${i}</span>`; pageNumElement.dataset.page = i; if (i === currentIndex + 1) pageNumElement.classList.add('current'); pageNumElement.addEventListener('click', handleJumpNumberClick); listContainer.appendChild(pageNumElement); } overlay.appendChild(listContainer); }
    function handleJumpNumberClick(event) { /* 내용 동일, 생략 */ const targetPage = parseInt(event.currentTarget.dataset.page, 10); if (!isNaN(targetPage)) { showImage(targetPage - 1); removePageJumpUI(); } }
    function removePageJumpUI() { /* 내용 동일, 생략 */ if (pageJumpOverlay) { pageJumpOverlay.remove(); pageJumpOverlay = null; } fullscreenContainer.classList.remove('jump-ui-active'); }

    // --- 터치 이벤트 핸들러 (로그 추가) ---
           // ▼▼▼ 최종 수정 handlePointerDown 함수 ▼▼▼
    function handlePointerDown(event) {
        console.log('[Pointer Down]', 'Type:', event.type, 'Touches:', event.touches ? event.touches.length : 0, 'States:', { isPinching, isPanning, isDragging, pointerDown });

        // --- ★★★ 가장 먼저 이미 핀치 중인지 확인! ★★★ ---
        if (isPinching) {
            console.log("[PointerDown] Ignored: Already pinching (isPinching is true).");
            return; // 이미 핀치 제스처 중이면 어떤 포인터 다운도 무시
        }
        // --- ★★★ ---

        // 뷰어 요소 및 마우스 버튼 체크
        if (pageJumpOverlay || !viewerImage) return;
        if (event.button && event.button !== 0 && event.type === 'mousedown') return; // 마우스 오른쪽 등 무시

        // --- 핀치 시작 감지 ---
        // (isPinching이 false임이 보장된 상태에서 실행됨)
        if (event.type === 'touchstart' && event.touches.length === 2) {
            console.log(">>> Pinch Start Detected! Setting isPinching=true <<<");
            event.preventDefault();
            isPinching = true;
            isPanning = false; // 핀치 시 다른 상태 초기화
            isDragging = false;
            // 중요: 싱글 터치 상태(pointerDown)도 해제해야 함 (첫번째 손가락이 down 상태일 수 있으므로)
            if (pointerDown) {
                 console.log("[Pinch Start] Clearing single touch state (pointerDown=false)");
                 pointerDown = false;
                 // 싱글 터치용 리스너도 여기서 확실히 제거
                 document.removeEventListener('mousemove', handlePointerMove);
                 document.removeEventListener('touchmove', handlePointerMove);
                 document.removeEventListener('mouseup', handlePointerUp);
                 document.removeEventListener('touchend', handlePointerUp);
                 document.removeEventListener('mouseleave', handlePointerUp);
            }

            initialDistance = getDistance(event.touches[0], event.touches[1]);
            const midpoint = getMidpoint(event.touches[0], event.touches[1]);
            lastScale = currentScale;
            lastTranslateX = translateX;
            lastTranslateY = translateY;
            pinchCenterX = midpoint.x;
            pinchCenterY = midpoint.y;
            // 핀치 중에는 document 레벨 리스너 불필요 (move/up에서 isPinching으로 분기)

            return; // 핀치 시작 처리 후 종료
        }

        // --- 싱글 터치 시작 처리 ---
        // (isPinching이 false이고, 핀치 시작 조건도 아닐 때 실행됨)

        // 이미 다른 싱글 터치가 진행 중인지 확인 (이론상 불필요하지만 방어 코드)
        if (pointerDown) {
            console.log("[PointerDown] Ignored: Already single-touching (pointerDown is true).");
            return;
        }

        // 터치 시작 시 손가락 개수 확인 (3개 이상 터치 무시)
        if (event.type === 'touchstart' && event.touches.length !== 1) {
             console.log("[PointerDown] Ignored: Not a single touch start (touches:", event.touches.length, ")");
             return;
        }

        // 여기가 싱글 터치 시작 지점
        pointerDown = true;
        isDragging = false;
        isPanning = false;
        dragStartTime = Date.now();
        clearTimeout(clickTimeoutId);
        console.log(">>> Single Touch Start (pointerDown=true) <<<");

        const touch = event.type.startsWith('touch');
        startX = touch ? event.touches[0].clientX : event.clientX;
        currentX = startX;
        clickStartX = startX;
        clickStartY = touch ? event.touches[0].clientY : event.clientY;

        if (currentScale > 1) { // 확대 상태면 패닝 시작
            console.log("Starting Panning (isPanning=true)");
            isPanning = true;
            panStartX = clickStartX;
            panStartY = clickStartY;
            lastTranslateX = translateX;
            lastTranslateY = translateY;
            if (viewerImage) viewerImage.classList.add('panning');
        } else { // 확대 안됐으면 스와이프/클릭 준비
             console.log("Ready for Swipe/Click (isDragging=false)");
             isDragging = false;
        }

        // 싱글 터치 이동/종료를 위한 공통 리스너 추가
        console.log("[PointerDown] Adding document listeners for single touch");
        document.addEventListener('mousemove', handlePointerMove);
        document.addEventListener('touchmove', handlePointerMove, { passive: false });
        document.addEventListener('mouseup', handlePointerUp);
        document.addEventListener('touchend', handlePointerUp);
        document.addEventListener('mouseleave', handlePointerUp);
    }
    // ▲▲▲ 최종 수정 handlePointerDown 함수 ▲▲▲

    // ▼▼▼ handlePointerMove 함수에 로그 추가 ▼▼▼
    function handlePointerMove(event) {
        // console.log('[Pointer Move]', 'Type:', event.type, 'Touches:', event.touches ? event.touches.length : 0, 'States:', { isPinching, isPanning, isDragging, pointerDown }); // 필요시 주석 해제
        if (isPinching && event.type === 'touchmove' && event.touches.length === 2) {
            // console.log(">>> Pinch Move Detected! <<<"); // 너무 많이 찍힐 수 있음
            event.preventDefault(); const currentDistance = getDistance(event.touches[0], event.touches[1]); if (initialDistance === 0) return; let scale = (currentDistance / initialDistance) * lastScale; scale = Math.max(minScale, Math.min(maxScale, scale));
            console.log("[Pinch Move] Calculated Scale:", scale, "Previous Scale:", currentScale); // 스케일 변화 로그
            currentScale = scale; applyTransform(); return;
        }
        if (!pointerDown) return;
        const touch = event.type.startsWith('touch'); const currentMoveX = touch ? event.touches[0].clientX : event.clientX; const currentMoveY = touch ? event.touches[0].clientY : event.clientY;
        if (isPanning) {
            // console.log(">>> Panning Move! <<<"); // 너무 많이 찍힐 수 있음
            event.preventDefault(); translateX = lastTranslateX + (currentMoveX - panStartX); translateY = lastTranslateY + (currentMoveY - panStartY); applyTransform();
        } else {
             if (!isDragging) { const moveX = Math.abs(currentMoveX - clickStartX); const moveY = Math.abs(currentMoveY - clickStartY); if (moveX > dragStartThreshold || moveY > dragStartThreshold) { isDragging = true; console.log(">>> Dragging Start (isDragging=true) <<<"); } } // 드래그 시작 로그
             if (isDragging) currentX = currentMoveX;
        }
    }
    // ▲▲▲ handlePointerMove 함수에 로그 추가 ▲▲▲

    // ▼▼▼ handlePointerUp 함수에 로그 추가 (이전 최종 버전 유지) ▼▼▼
    function handlePointerUp(event) {
        const isTouchEnd = event.type === 'touchend';
        console.log('[PointerUp START]', 'Type:', event.type, 'Touches:', event.touches ? event.touches.length : 0, 'States:', { isPinching, isPanning, isDragging, pointerDown }); // 시작 로그

        let pinchJustEnded = false;
        if (isPinching) {
            console.log(">>> Pinch End Detected! Setting isPinching=false <<<"); // 핀치 종료 로그
            isPinching = false; pinchJustEnded = true;
            if (currentScale > 1) { console.log("[Pinch End] Saving last translate:", { lastTranslateX: translateX, lastTranslateY: translateY }); lastTranslateX = translateX; lastTranslateY = translateY; }
            else { console.log("[Pinch End] Scale <= 1, Resetting transform."); translateX = 0; translateY = 0; lastTranslateX = 0; lastTranslateY = 0; applyTransform(); }
        }

        if (pointerDown || pinchJustEnded) {
             if (pointerDown) { console.log(">>> Single Touch End (Setting pointerDown=false) <<<"); pointerDown = false; } // 싱글 터치 종료 로그
            const wasDragging = isDragging; const wasPanning = isPanning;
            isDragging = false; isPanning = false;
            console.log("[PointerUp] Removing document listeners"); // 리스너 제거 로그
            document.removeEventListener('mousemove', handlePointerMove); document.removeEventListener('touchmove', handlePointerMove); document.removeEventListener('mouseup', handlePointerUp); document.removeEventListener('touchend', handlePointerUp); document.removeEventListener('mouseleave', handlePointerUp);
            if (!viewerImage) { console.log("[PointerUp] No viewerImage, returning."); return; }
            viewerImage.classList.remove('panning');

            if (!pinchJustEnded) { // 싱글 터치 후속 동작
                const dragDuration = Date.now() - dragStartTime;
                const endX = isTouchEnd ? (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0].clientX : currentX) : event.clientX;
                const endY = isTouchEnd ? (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0].clientY : clickStartY) : event.clientY;
                const totalMoveX = Math.abs(endX - clickStartX); const totalMoveY = Math.abs(endY - clickStartY);

                if (wasPanning) { console.log("[Single Touch End] Was Panning. Saving last translate:", { lastTranslateX: translateX, lastTranslateY: translateY }); lastTranslateX = translateX; lastTranslateY = translateY; }
                else if (currentScale <= 1) {
                    console.log("[Single Touch End] Scale <= 1. Checking for click/swipe."); // 클릭/스와이프 확인 로그
                    if (totalMoveX < clickMoveThreshold && totalMoveY < clickMoveThreshold && dragDuration < clickTimeThreshold) {
                        console.log(">>> Click Detected! <<<"); // 클릭 감지 로그
                        clearTimeout(clickTimeoutId); clickTimeoutId = setTimeout(() => { console.log("Executing nextImage() after debounce"); nextImage(); }, clickDebounceTime);
                    } else if (wasDragging && Math.abs(currentX - startX) >= swipeThreshold) {
                         console.log(">>> Swipe Detected! <<<", currentX - startX > 0 ? "Swipe Right (Prev)" : "Swipe Left (Next)"); // 스와이프 감지 로그
                         clearTimeout(clickTimeoutId); if (currentX - startX > 0) prevImage(); else nextImage();
                    } else { console.log("[Single Touch End] No click or swipe detected."); } // 클릭/스와이프 아님 로그
                } else { console.log("[Single Touch End] Scale > 1, but was not panning? Saving last translate."); lastTranslateX = translateX; lastTranslateY = translateY; }
            } else { console.log("[PointerUp] Processed pinch end. No further action needed."); } // 핀치 종료 후 추가 동작 없음 로그
        } else if (!isPinching) {
             console.log("[PointerUp] Ignored: Neither pinch nor single touch was active."); // 무시 로그
             document.removeEventListener('mousemove', handlePointerMove); document.removeEventListener('touchmove', handlePointerMove); document.removeEventListener('mouseup', handlePointerUp); document.removeEventListener('touchend', handlePointerUp); document.removeEventListener('mouseleave', handlePointerUp);
        }
        console.log('[PointerUp END]', 'Final States:', { isPinching, isPanning, isDragging, pointerDown }); // 종료 로그
    }
    // ▲▲▲ handlePointerUp 함수에 로그 추가 ▲▲▲

    // --- 뷰어 열기/닫기, 이미지 넘김, 키보드 이벤트 함수 ---
    function openFullscreen(index) { /* 내용 동일, 생략 */ if (isFullscreen) return; currentIndex = index; isFullscreen = true; const imageUrl = imageFiles[currentIndex]; if (!imageUrl) { console.error("Invalid image index:", index); isFullscreen = false; return; } bodyElement.classList.add('fullscreen-active'); fullscreenViewer = document.createElement('div'); fullscreenViewer.classList.add('fullscreen-viewer'); fullscreenViewer.innerHTML = `<img src="${imageUrl}" alt="${workConfig.title || 'Image'} - Image ${currentIndex + 1}">`; viewerImage = fullscreenViewer.querySelector('img'); viewerImage.addEventListener('mousedown', handlePointerDown); viewerImage.addEventListener('touchstart', handlePointerDown, { passive: false }); viewerImage.onload = () => { preloadImage(currentIndex + 1); preloadImage(currentIndex - 1); }; viewerImage.onerror = () => { console.error("Failed load:", imageUrl); viewerImage.alt="이미지 로드 실패"; }; fullscreenViewer.addEventListener('click', handleViewerClick); counterContainer = document.createElement('div'); counterContainer.className = 'counter-container'; counterElement = document.createElement("div"); counterElement.className = "fancybox__counter"; counterElement.addEventListener('click', togglePageJumpUI); counterContainer.appendChild(counterElement); fullscreenContainer.appendChild(fullscreenViewer); fullscreenContainer.appendChild(counterContainer); updateCounter(); document.addEventListener('keydown', handleKeydown); requestAnimationFrame(() => { if (fullscreenViewer) fullscreenViewer.classList.add('active'); }); }
    function handleViewerClick(event) { /* 내용 동일, 생략 */ if (!pageJumpOverlay && !isPanning && currentScale <= 1 && event.target === fullscreenViewer) closeFullscreen(); }
    function closeFullscreen() { /* 내용 동일, 생략 */ if (!isFullscreen) return; isFullscreen = false; removePageJumpUI(); bodyElement.classList.remove('fullscreen-active'); clearTimeout(clickTimeoutId); if (viewerImage) { viewerImage.removeEventListener('mousedown', handlePointerDown); viewerImage.removeEventListener('touchstart', handlePointerDown); } if (fullscreenViewer) fullscreenViewer.removeEventListener('click', handleViewerClick); if (counterElement) counterElement.removeEventListener('click', togglePageJumpUI); document.removeEventListener('keydown', handleKeydown); if (thumbnailObserver) thumbnailObserver.disconnect(); if (imageLazyLoadObserver) imageLazyLoadObserver.disconnect(); thumbnailObserver = null; imageLazyLoadObserver = null; if (fullscreenViewer) fullscreenViewer.classList.remove('active'); setTimeout(() => { fullscreenContainer.innerHTML = ''; fullscreenViewer = null; viewerImage = null; counterContainer = null; counterElement = null; pageJumpOverlay = null; isDragging = false; pointerDown = false; isPinching = false; isPanning = false; currentScale = 1; translateX = 0; translateY = 0; lastScale = 1; lastTranslateX = 0; lastTranslateY = 0; preloadCache.clear(); }, 300); }
    function nextImage() { /* 내용 동일, 생략 */ if (isFullscreen && !pageJumpOverlay && currentScale <= 1) showImage((currentIndex + 1) % imageFiles.length); }
    function prevImage() { /* 내용 동일, 생략 */ if (isFullscreen && !pageJumpOverlay && currentScale <= 1) showImage((currentIndex - 1 + imageFiles.length) % imageFiles.length); }
    function handleKeydown(event) { /* 내용 동일, 생략 */ if (pageJumpOverlay) { if (event.key === 'Escape') removePageJumpUI(); return; } if (isFullscreen) { if (event.key === 'Escape') closeFullscreen(); } }

    // --- 초기화 ---
    document.addEventListener('DOMContentLoaded', () => { /* 내용 동일, 생략 */ if (typeof workConfig !== 'undefined') { document.title = workConfig.title || "작품 뷰어"; if (workTitleElement) workTitleElement.textContent = workConfig.title || "제목 없음"; if (workAuthorElement) workAuthorElement.textContent = `작가: ${workConfig.author || "작자 미상"}`; generateThumbnails(0, itemsPerLoad); setupThumbnailObserver(); } else { console.error("Initialization failed because workConfig is not defined."); } });
  </script>
</body>
</html>