<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <!-- 제목은 JS로 설정 -->
  <title>작품 뷰어</title>
  <style>
    /* --- 기본 스타일 --- */
    body { font-family: sans-serif; padding: 1rem; background: #fff; margin: 0; }
    body.fullscreen-active { overflow: hidden; }

    .info { text-align: center; margin-bottom: 1rem; }
    .info h2 { margin: 0.5rem 0; }
    .info .author { color: #555; font-size: 0.9em; margin-top: 0.2rem;}
    .images { display: flex; flex-direction: column; gap: 10px; align-items: center; }
    .images a { /* 링크 요소 스타일 */
        display: block; width: 90%; max-width: 300px;
        min-height: 150px; background-color: #eee; border-radius: 8px;
        overflow: hidden;
    }
    .images img {
        display: block; width: 100%; height: auto;
        /* max-width/max-height 제거 */
        /* border-radius 제거 (a에서 처리) */
        box-shadow: 0 0 8px rgba(0,0,0,0.1); cursor: pointer;
        opacity: 0; transition: opacity 0.5s ease-in-out;
    }
    .images img.lazyloaded { opacity: 1; }
    #fullscreen-container { position: relative; }

    /* --- 카운터 --- */
    .counter-container { position: fixed; top: 10px; right: 10px; z-index: 10002; }
    .fancybox__counter {
      font-size: 16px; background: rgba(0, 0, 0, 0.6); color: #fff;
      padding: 4px 10px; border-radius: 12px; user-select: none;
      cursor: pointer; display: inline-block;
    }
    .fullscreen-container.jump-ui-active .counter-container { opacity: 0.2; pointer-events: none; }

    /* --- 전체 화면 뷰어 --- */
    .fullscreen-viewer {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.9); display: flex;
      justify-content: center; align-items: center; z-index: 9999;
      opacity: 0; visibility: hidden;
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      overflow: hidden;
    }
    .fullscreen-viewer.active { opacity: 1; visibility: visible; }
    .fullscreen-viewer img {
      max-width: 95%; max-height: 95%; object-fit: contain;
      cursor: grab; user-select: none; -webkit-user-drag: none;
      transition: opacity 0.2s ease-out; /* transform 제외 */
      touch-action: none; /* 중요: 브라우저 기본 터치 액션 방지 */
      transform-origin: center center; /* 확대/축소 기준점 */
    }
    /* 드래깅/패닝 중 스타일 */
    .fullscreen-viewer img.dragging,
    .fullscreen-viewer img.panning {
        cursor: grabbing;
    }

    /* --- 페이지 점프 UI (세로 스크롤 목록) - 중요! 이 부분 CSS 확인 --- */
    .page-jump-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7); display: flex;
      justify-content: center; align-items: center;
      z-index: 10001; cursor: pointer;
    }
    #page-jump-list {
      background-color: #333; /* 어두운 배경 */
      color: #eee; /* 밝은 글씨 */
      padding: 10px 0; /* 위아래 패딩, 좌우는 항목에서 */
      border-radius: 10px;
      max-height: 70vh; /* 높이 제한 */
      overflow-y: auto; /* 세로 스크롤 */
      display: flex;
      flex-direction: column; /* 세로 방향 */
      gap: 0px; /* 항목 사이 간격 제거 */
      cursor: default;
      width: 200px; /* 목록 너비 고정 */
      scrollbar-width: thin;
      scrollbar-color: #666 #333;
    }
    #page-jump-list::-webkit-scrollbar { width: 6px; }
    #page-jump-list::-webkit-scrollbar-track { background: #333; }
    #page-jump-list::-webkit-scrollbar-thumb { background-color: #666; border-radius: 3px; }

    .page-jump-number {
      display: flex; /* 숫자와 원 정렬 */
      align-items: center;
      justify-content: space-between; /* 숫자 왼쪽, 원 오른쪽 */
      padding: 12px 15px; /* 항목 내부 패딩 */
      cursor: pointer;
      font-weight: normal; /* 기본 글꼴 두께 */
      text-align: left; /* 숫자 왼쪽 정렬 */
      transition: background-color 0.2s ease;
      border-bottom: 1px solid #444; /* 항목 구분선 */
      font-size: 16px;
    }
    .page-jump-number:last-child { border-bottom: none; }
    .page-jump-number:hover { background-color: #444; }

    /* 라디오 버튼 스타일 원 */
    .page-jump-number::after {
      content: ''; display: inline-block; width: 18px; height: 18px;
      border-radius: 50%; border: 2px solid #888; /* 원 테두리 */
      margin-left: 15px; position: relative; box-sizing: border-box;
    }
    /* 현재 페이지 표시 (채워진 원) */
    .page-jump-number.current { font-weight: bold; }
    .page-jump-number.current::after { border-color: #eee; background-color: #eee; }

  </style>
</head>
<body>
  <div class="info">
    <h2 id="work-title"></h2>
    <p class="author" id="work-author"></p>
  </div>
  <div class="images"></div>
  <div id="load-more-trigger" style="height: 50px;"></div> <!-- 썸네일 더보기용 -->
  <div id="fullscreen-container"></div>

  <!-- ▼▼▼ config.js 로드 스크립트 추가 ▼▼▼ -->
  <script src="config.js"></script>
  <!-- ▲▲▲ config.js 로드 스크립트 추가 ▲▲▲ -->

  <script> // 메인 뷰어 스크립트 시작
    // *** config.js의 workConfig 객체 사용 ***
    // config.js 파일이 workConfig 객체를 정의한다고 가정
    if (typeof workConfig === 'undefined' || !workConfig || !Array.isArray(workConfig.images)) {
        console.error("workConfig is not defined or invalid in config.js!");
        // 사용자에게 오류 메시지 표시 (예: body에 직접 추가)
        document.body.innerHTML = '<p style="color: red; text-align: center; margin-top: 2rem;">작품 설정(config.js)을 불러올 수 없습니다.</p>';
        // 스크립트 실행 중단 (throw new Error 사용 시)
        throw new Error("workConfig is not defined or invalid in config.js! Halting script execution."); // 오류 발생 시 스크립트 중단
    }

    // --- 전역 변수 및 요소 선택 ---
    const imageFiles = workConfig.images; // 이미지 목록 가져오기
    const fullscreenContainer = document.getElementById('fullscreen-container');
    const bodyElement = document.body;
    const imagesContainer = document.querySelector('.images');
    const workTitleElement = document.getElementById('work-title');
    const workAuthorElement = document.getElementById('work-author');
    const loadMoreTrigger = document.getElementById('load-more-trigger');

    // === 페이지 정보 설정 ===
    document.title = workConfig.title || "작품 뷰어"; // 제목 없으면 기본값
    if (workTitleElement) workTitleElement.textContent = workConfig.title || "제목 없음";
    if (workAuthorElement) workAuthorElement.textContent = `작가: ${workConfig.author || "작자 미상"}`;

    // --- 썸네일 지연 생성 관련 ---
    const itemsPerLoad = 10;
    let lastLoadedIndex = -1;
    let thumbnailObserver = null;
    let imageLazyLoadObserver = null; // 개별 이미지 로딩 옵저버

    function generateThumbnails(startIndex, count) {
        const fragment = document.createDocumentFragment();
        const endIndex = Math.min(startIndex + count, imageFiles.length);
        for (let index = startIndex; index < endIndex; index++) {
            if (index > lastLoadedIndex) {
                const filename = imageFiles[index];
                if (!filename) continue; // 파일 이름 없으면 건너뛰기

                const link = document.createElement('a');
                link.href = filename;
                link.dataset.index = index;

                const img = document.createElement('img');
                img.dataset.src = filename;
                img.alt = `${workConfig.title || 'Image'} - Image ${index + 1}`;
                img.loading = 'lazy'; // 브라우저 네이티브 지연 로딩 활용

                link.appendChild(img);
                fragment.appendChild(link);
                lastLoadedIndex = index;
            }
        }
        imagesContainer.appendChild(fragment);
        addViewerEventListeners(startIndex, endIndex); // 썸네일 클릭 리스너 추가
        setupImageLazyLoadForRange(startIndex, endIndex); // IntersectionObserver로 이미지 로딩 설정

        // 마지막 항목까지 로드되면 트리거 숨김
        if (endIndex >= imageFiles.length && thumbnailObserver && loadMoreTrigger) {
            thumbnailObserver.unobserve(loadMoreTrigger);
            loadMoreTrigger.style.display = 'none';
        }
    }

    function setupThumbnailObserver() {
        const options = { root: null, rootMargin: '0px 0px 300px 0px', threshold: 0.01 }; // 감지 영역 확장
        thumbnailObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    // 감지되면 다음 묶음 로드
                    generateThumbnails(lastLoadedIndex + 1, itemsPerLoad);
                }
            });
        }, options);
        if (loadMoreTrigger) {
            thumbnailObserver.observe(loadMoreTrigger);
        } else {
             console.warn("Load more trigger element not found.");
             // 트리거가 없으면 초기 로드 후 추가 로드 안됨
        }
    }

    function addViewerEventListeners(startIndex, endIndex) {
        // imagesContainer 내 새로 추가된 링크만 찾아서 이벤트 리스너 추가
        const links = imagesContainer.querySelectorAll(`a[data-index]:not([data-listener-added="true"])`);
        links.forEach(link => {
             const index = parseInt(link.dataset.index, 10);
             if (index >= startIndex && index < endIndex) {
                 link.addEventListener('click', handleThumbnailClick);
                 link.dataset.listenerAdded = 'true';
             }
        });
    }

    function handleThumbnailClick(event) {
        event.preventDefault();
        const index = parseInt(event.currentTarget.dataset.index, 10);
        if (!isNaN(index)) {
            openFullscreen(index);
        } else {
            console.error("Invalid index on thumbnail click:", event.currentTarget);
        }
    }

    // 범위 내 이미지들에 대해 IntersectionObserver 설정
    function setupImageLazyLoadForRange(startIndex, endIndex) {
        if (!imageLazyLoadObserver) {
            imageLazyLoadObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const lazyImage = entry.target;
                        if (lazyImage.dataset.src) {
                            lazyImage.src = lazyImage.dataset.src;
                            lazyImage.classList.add('lazyloaded'); // 로딩 완료 시 opacity 전환용
                            lazyImage.removeAttribute('data-src'); // 불필요 속성 제거
                            observer.unobserve(lazyImage); // 한번 로드되면 더 이상 관찰 안 함
                        }
                    }
                });
            }, { rootMargin: '0px 0px 150px 0px' }); // 뷰포트 아래 150px부터 로드 시작
        }

        // 새로 생성된 범위의 이미지들만 관찰 대상으로 추가
        const imagesToObserve = imagesContainer.querySelectorAll(`img[data-src]`);
        imagesToObserve.forEach(img => {
             // data-index를 확인하여 해당 범위 내 이미지인지 판단 (선택적 최적화)
             const parentLink = img.closest('a');
             if (parentLink && parentLink.dataset.index) {
                 const index = parseInt(parentLink.dataset.index, 10);
                 if (index >= startIndex && index < endIndex) {
                     imageLazyLoadObserver.observe(img);
                 }
             }
        });
    }

    // --- 뷰어 로직 시작 ---
    let currentIndex = 0;
    let isFullscreen = false;
    // ... (나머지 뷰어 관련 변수 선언 동일) ...
    let fullscreenViewer = null;
    let viewerImage = null;
    let counterContainer = null;
    let counterElement = null;
    let pageJumpOverlay = null;
    let isDragging = false;
    let startX = 0, currentX = 0, clickStartX = 0, clickStartY = 0, dragStartTime = 0;
    let pointerDown = false, clickTimeoutId = null;
    const swipeThreshold = 50, clickMoveThreshold = 15, clickTimeThreshold = 250;
    const dragStartThreshold = 5, clickDebounceTime = 60;
    const preloadCache = new Set(); // 프리로드 캐시

    // --- ▼▼▼ 핀치 줌 & 패닝 관련 변수 (추가) ▼▼▼ ---
    let isPinching = false;
    let isPanning = false;
    let initialDistance = 0;
    let currentScale = 1;
    let translateX = 0;
    let translateY = 0;
    let pinchCenterX = 0;
    let pinchCenterY = 0;
    let panStartX = 0;
    let panStartY = 0;
    let lastScale = 1;
    let lastTranslateX = 0;
    let lastTranslateY = 0;
    const minScale = 1;
    const maxScale = 5;
    // --- ▲▲▲ 핀치 줌 & 패닝 관련 변수 (추가) ▲▲▲ ---

    function preloadImage(index) {
        if (index < 0 || index >= imageFiles.length) return;
        const imageUrl = imageFiles[index];
        if (!imageUrl || preloadCache.has(imageUrl)) return;
        const img = new Image(); img.src = imageUrl;
        preloadCache.add(imageUrl);
        // console.log("Preloading:", imageUrl); // 디버깅용
    }
    function updateCounter() {
      if (counterElement) {
        counterElement.innerText = `${currentIndex + 1} / ${imageFiles.length}`;
      }
    }
    // === 이미지 표시 및 상태 리셋 함수 (줌/패닝 상태 리셋 추가) ===
    function showImage(index) {
        if (!isFullscreen) return;
        if (index >= 0 && index < imageFiles.length) {
            currentIndex = index;
            const imageUrl = imageFiles[currentIndex];
            if (!imageUrl) { // 이미지 URL 유효성 검사
                console.error(`Image URL is invalid for index: ${index}`);
                return;
            }
            if (viewerImage) {
                // --- 줌/패닝 상태 초기화 ---
                currentScale = 1; translateX = 0; translateY = 0;
                lastScale = 1; lastTranslateX = 0; lastTranslateY = 0;
                isPinching = false; isPanning = false;
                applyTransform(); // 리셋 적용

                viewerImage.src = imageUrl; // 새 이미지 로드
                updateCounter();
                preloadImage(currentIndex + 1); // 다음 이미지 프리로드
                preloadImage(currentIndex - 1); // 이전 이미지 프리로드
            }
        } else { console.warn(`Invalid index requested: ${index}`); }
    }

    // === ▼▼▼ 핀치/패닝 관련 헬퍼 함수 (추가) ▼▼▼ ===
    function getDistance(p1, p2) {
        const dx = p1.clientX - p2.clientX; const dy = p1.clientY - p2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    function getMidpoint(p1, p2) {
        return { x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 };
    }
    function applyTransform() {
        if (viewerImage) {
            const { constrainedX, constrainedY } = constrainPanning(translateX, translateY, currentScale);
            translateX = constrainedX; translateY = constrainedY;
            lastTranslateX = translateX; lastTranslateY = translateY;
            viewerImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
        }
    }
    function constrainPanning(newX, newY, scale) {
        if (!viewerImage || scale <= 1) return { constrainedX: 0, constrainedY: 0 };
        const naturalWidth = viewerImage.offsetWidth; const naturalHeight = viewerImage.offsetHeight;
        if (naturalWidth === 0 || naturalHeight === 0) return { constrainedX: 0, constrainedY: 0 }; // 이미지 크기 0일 때 오류 방지
        const scaledWidth = naturalWidth * scale; const scaledHeight = naturalHeight * scale;
        const maxX = Math.max(0, (scaledWidth - window.innerWidth) / 2); const minX = -maxX;
        const maxY = Math.max(0, (scaledHeight - window.innerHeight) / 2); const minY = -maxY;
        const constrainedX = Math.max(minX, Math.min(maxX, newX));
        const constrainedY = Math.max(minY, Math.min(maxY, newY));
        return { constrainedX, constrainedY };
    }
    // === ▲▲▲ 핀치/패닝 관련 헬퍼 함수 (추가) ▲▲▲ ===

    function togglePageJumpUI() {
        if (!isFullscreen) return;
        if (pageJumpOverlay) { removePageJumpUI(); return; }
        pageJumpOverlay = document.createElement('div');
        pageJumpOverlay.className = 'page-jump-overlay';
        pageJumpOverlay.addEventListener('click', handleOverlayClick);
        createPageJumpList(pageJumpOverlay);
        fullscreenContainer.appendChild(pageJumpOverlay);
        fullscreenContainer.classList.add('jump-ui-active');
        const currentButton = pageJumpOverlay.querySelector(`.page-jump-number.current`);
        if (currentButton) currentButton.scrollIntoView({ behavior: 'smooth', block: 'center' }); // 부드럽게 스크롤
    }
    function handleOverlayClick(event) { if (event.target === pageJumpOverlay) removePageJumpUI(); }
    function createPageJumpList(overlay) {
        const listContainer = document.createElement('div'); listContainer.id = 'page-jump-list';
        listContainer.addEventListener('click', (e) => e.stopPropagation());
        for (let i = 1; i <= imageFiles.length; i++) {
            const pageNumElement = document.createElement('div'); pageNumElement.className = 'page-jump-number';
            pageNumElement.innerHTML = `<span>${i}</span>`; pageNumElement.dataset.page = i;
            if (i === currentIndex + 1) pageNumElement.classList.add('current');
            pageNumElement.addEventListener('click', handleJumpNumberClick);
            listContainer.appendChild(pageNumElement);
        }
        overlay.appendChild(listContainer);
    }
    function handleJumpNumberClick(event) {
        const targetPage = parseInt(event.currentTarget.dataset.page, 10);
        if (!isNaN(targetPage)) {
             showImage(targetPage - 1);
             removePageJumpUI();
        }
    }
    function removePageJumpUI() {
        if (pageJumpOverlay) { pageJumpOverlay.remove(); pageJumpOverlay = null; }
        fullscreenContainer.classList.remove('jump-ui-active');
    }

    // === ▼▼▼ 터치 이벤트 핸들러 수정 및 추가 ▼▼▼ ===
    function handlePointerDown(event) {
        if (pageJumpOverlay || !viewerImage) return;
        if (event.button && event.button !== 0 && event.type === 'mousedown') return;

        if (event.type === 'touchstart' && event.touches.length === 2) { // 핀치 시작
            event.preventDefault(); isPinching = true; isPanning = false; isDragging = false; pointerDown = false;
            initialDistance = getDistance(event.touches[0], event.touches[1]);
            const midpoint = getMidpoint(event.touches[0], event.touches[1]);
            lastScale = currentScale; lastTranslateX = translateX; lastTranslateY = translateY;
            pinchCenterX = midpoint.x; pinchCenterY = midpoint.y;
            document.removeEventListener('mousemove', handlePointerMove); document.removeEventListener('touchmove', handlePointerMove);
            document.removeEventListener('mouseup', handlePointerUp); document.removeEventListener('touchend', handlePointerUp); document.removeEventListener('mouseleave', handlePointerUp);
            return;
        }
        if (event.type === 'touchstart' && event.touches.length > 1) return; // 세 손가락 이상 무시
        if (pointerDown || isPinching) return; // 다른 동작 중 무시

        pointerDown = true; isDragging = false; isPanning = false; dragStartTime = Date.now(); clearTimeout(clickTimeoutId);
        const touch = event.type.startsWith('touch');
        startX = touch ? event.touches[0].clientX : event.clientX; currentX = startX;
        clickStartX = startX; clickStartY = touch ? event.touches[0].clientY : event.clientY;

        if (currentScale > 1) { // 패닝 시작
            isPanning = true; panStartX = clickStartX; panStartY = clickStartY;
            lastTranslateX = translateX; lastTranslateY = translateY;
            if (viewerImage) viewerImage.classList.add('panning');
        } // else: 스와이프 시작 준비

        document.addEventListener('mousemove', handlePointerMove); document.addEventListener('touchmove', handlePointerMove, { passive: false });
        document.addEventListener('mouseup', handlePointerUp); document.addEventListener('touchend', handlePointerUp); document.addEventListener('mouseleave', handlePointerUp);
    }
    function handlePointerMove(event) {
        if (isPinching && event.type === 'touchmove' && event.touches.length === 2) { // 핀치 중
            event.preventDefault();
            const currentDistance = getDistance(event.touches[0], event.touches[1]);
            if (initialDistance === 0) return; // 거리 0 오류 방지
            let scale = (currentDistance / initialDistance) * lastScale;
            scale = Math.max(minScale, Math.min(maxScale, scale)); currentScale = scale;
            applyTransform(); return;
        }
        if (!pointerDown) return; // 싱글 터치 아니면 무시

        const touch = event.type.startsWith('touch');
        const currentMoveX = touch ? event.touches[0].clientX : event.clientX; const currentMoveY = touch ? event.touches[0].clientY : event.clientY;

        if (isPanning) { // 패닝 중
            event.preventDefault();
            translateX = lastTranslateX + (currentMoveX - panStartX); translateY = lastTranslateY + (currentMoveY - panStartY);
            applyTransform();
        } else { // 스와이프 판정
            if (!isDragging) {
                const moveX = Math.abs(currentMoveX - clickStartX); const moveY = Math.abs(currentMoveY - clickStartY);
                if (moveX > dragStartThreshold || moveY > dragStartThreshold) isDragging = true;
            }
            if (isDragging) currentX = currentMoveX; // 스와이프 거리 계산용
        }
    }
    function handlePointerUp(event) {
        if (isPinching) { // 핀치 종료
            if (event.type === 'touchend' && event.touches.length < 2) {
                isPinching = false;
                if (currentScale > 1) { lastTranslateX = translateX; lastTranslateY = translateY; }
                else { translateX = 0; translateY = 0; lastTranslateX = 0; lastTranslateY = 0; applyTransform(); }
            } return;
        }
        if (!pointerDown) return; // 싱글 터치 아니면 무시

        pointerDown = false; const wasDragging = isDragging; const wasPanning = isPanning;
        isDragging = false; isPanning = false;
        document.removeEventListener('mousemove', handlePointerMove); document.removeEventListener('touchmove', handlePointerMove);
        document.removeEventListener('mouseup', handlePointerUp); document.removeEventListener('touchend', handlePointerUp); document.removeEventListener('mouseleave', handlePointerUp);
        if (!viewerImage) return;
        viewerImage.classList.remove('panning');

        const dragDuration = Date.now() - dragStartTime; const touch = event.type === 'touchend';
        const endX = touch ? (event.changedTouches[0] ? event.changedTouches[0].clientX : currentX) : event.clientX;
        const endY = touch ? (event.changedTouches[0] ? event.changedTouches[0].clientY : clickStartY) : event.clientY;
        const totalMoveX = Math.abs(endX - clickStartX); const totalMoveY = Math.abs(endY - clickStartY);

        if (wasPanning) { /* 패닝 종료 시 추가 동작 없음 */ }
        else if (currentScale <= 1) { // 확대 안된 상태에서 터치 종료
            if (totalMoveX < clickMoveThreshold && totalMoveY < clickMoveThreshold && dragDuration < clickTimeThreshold) { // 클릭 판정
                clearTimeout(clickTimeoutId); clickTimeoutId = setTimeout(() => { nextImage(); }, clickDebounceTime); return;
            }
            if (wasDragging && Math.abs(currentX - startX) >= swipeThreshold) { // 스와이프 판정
                 clearTimeout(clickTimeoutId);
                 if (currentX - startX > 0) prevImage(); else nextImage(); return;
            }
        }
    }
    // === ▲▲▲ 터치 이벤트 핸들러 수정 및 추가 ▲▲▲ ===

    // === 뷰어 열기 ===
    function openFullscreen(index) {
        if (isFullscreen) return;
        currentIndex = index; isFullscreen = true;
        const imageUrl = imageFiles[currentIndex];
        if (!imageUrl) { console.error("Invalid image index:", index); isFullscreen = false; return; } // 유효하지 않으면 열지 않음
        bodyElement.classList.add('fullscreen-active');
        fullscreenViewer = document.createElement('div'); fullscreenViewer.classList.add('fullscreen-viewer');
        fullscreenViewer.innerHTML = `<img src="${imageUrl}" alt="${workConfig.title || 'Image'} - Image ${currentIndex + 1}">`;
        viewerImage = fullscreenViewer.querySelector('img');
        // 이벤트 리스너 연결
        viewerImage.addEventListener('mousedown', handlePointerDown); viewerImage.addEventListener('touchstart', handlePointerDown, { passive: false });
        viewerImage.onload = () => { preloadImage(currentIndex + 1); preloadImage(currentIndex - 1); };
        viewerImage.onerror = () => { console.error("Failed load:", imageUrl); viewerImage.alt="이미지 로드 실패"; /* 대체 텍스트 */ };
        fullscreenViewer.addEventListener('click', handleViewerClick);
        // 카운터 생성
        counterContainer = document.createElement('div'); counterContainer.className = 'counter-container';
        counterElement = document.createElement("div"); counterElement.className = "fancybox__counter";
        counterElement.addEventListener('click', togglePageJumpUI); counterContainer.appendChild(counterElement);
        // DOM에 추가
        fullscreenContainer.appendChild(fullscreenViewer); fullscreenContainer.appendChild(counterContainer);
        updateCounter();
        document.addEventListener('keydown', handleKeydown);
        requestAnimationFrame(() => { if (fullscreenViewer) fullscreenViewer.classList.add('active'); });
    }

    function handleViewerClick(event) {
        // 확대 안된 상태 & 패닝중 아님 & 배경 클릭 시 닫기
        if (!pageJumpOverlay && !isPanning && currentScale <= 1 && event.target === fullscreenViewer) {
            closeFullscreen();
        }
    }
    // === 뷰어 닫기 ===
    function closeFullscreen() {
        if (!isFullscreen) return; isFullscreen = false; removePageJumpUI(); bodyElement.classList.remove('fullscreen-active'); clearTimeout(clickTimeoutId);
        // 이벤트 리스너 제거
        if (viewerImage) { viewerImage.removeEventListener('mousedown', handlePointerDown); viewerImage.removeEventListener('touchstart', handlePointerDown); }
        if (fullscreenViewer) fullscreenViewer.removeEventListener('click', handleViewerClick);
        if (counterElement) counterElement.removeEventListener('click', togglePageJumpUI);
        document.removeEventListener('keydown', handleKeydown);
        // Intersection Observers 중지
        if (thumbnailObserver) thumbnailObserver.disconnect(); if (imageLazyLoadObserver) imageLazyLoadObserver.disconnect();
        thumbnailObserver = null; imageLazyLoadObserver = null; // 참조 제거
        // 뷰어 제거 및 상태 초기화
        if (fullscreenViewer) fullscreenViewer.classList.remove('active');
        setTimeout(() => {
            fullscreenContainer.innerHTML = ''; // 내부 요소 모두 제거
            fullscreenViewer = null; viewerImage = null; counterContainer = null; counterElement = null; pageJumpOverlay = null;
            isDragging = false; pointerDown = false; isPinching = false; isPanning = false;
            currentScale = 1; translateX = 0; translateY = 0; lastScale = 1; lastTranslateX = 0; lastTranslateY = 0;
            // lastLoadedIndex = -1; // 썸네일 상태는 유지해야 할 수도 있음 (페이지 새로고침 전까지)
            preloadCache.clear();
            // 뷰어 닫힌 후 썸네일 로딩 재개 (필요시)
            // setupThumbnailObserver();
        }, 300);
    }
    // === 다음/이전 이미지 ===
    function nextImage() { if (isFullscreen && !pageJumpOverlay && currentScale <= 1) showImage((currentIndex + 1) % imageFiles.length); }
    function prevImage() { if (isFullscreen && !pageJumpOverlay && currentScale <= 1) showImage((currentIndex - 1 + imageFiles.length) % imageFiles.length); }
    // === 키보드 이벤트 ===
    function handleKeydown(event) {
        if (pageJumpOverlay) { if (event.key === 'Escape') removePageJumpUI(); return; }
        if (isFullscreen) {
            if (event.key === 'Escape') closeFullscreen();
            // 확대 상태에서는 좌우키/스페이스로 이미지 넘기지 않음
            // else if (currentScale <= 1 && (event.key === 'ArrowRight' || event.key === ' ')) nextImage();
            // else if (currentScale <= 1 && event.key === 'ArrowLeft') prevImage();
        }
    }

    // --- 초기화 ---
    // DOMContentLoaded 이벤트 리스너 추가 (더 안전)
    document.addEventListener('DOMContentLoaded', () => {
        if (typeof workConfig !== 'undefined') {
            // 페이지 정보 설정
             document.title = workConfig.title || "작품 뷰어";
             if (workTitleElement) workTitleElement.textContent = workConfig.title || "제목 없음";
             if (workAuthorElement) workAuthorElement.textContent = `작가: ${workConfig.author || "작자 미상"}`;

            // 초기 썸네일 로드 및 스크롤 감지 시작
            generateThumbnails(0, itemsPerLoad);
            setupThumbnailObserver();
        } else {
            // config.js 로드 실패 시 오류 처리는 스크립트 상단에서 이미 수행됨
            console.error("Initialization failed because workConfig is not defined.");
        }
    });

  </script>
</body>
</html>