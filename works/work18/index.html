<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>작품 뷰어</title>
  <style>
    /* CSS 내용은 이전과 동일 */
    body { font-family: sans-serif; padding: 1rem; background: #fff; margin: 0; } body.fullscreen-active { overflow: hidden; } .info { text-align: center; margin-bottom: 1rem; } .info h2 { margin: 0.5rem 0; } .info .author { color: #555; font-size: 0.9em; margin-top: 0.2rem;} .images { display: flex; flex-direction: column; gap: 10px; align-items: center; } .images a { display: block; width: 90%; max-width: 300px; min-height: 150px; background-color: #eee; border-radius: 8px; overflow: hidden; } .images img { display: block; width: 100%; height: auto; box-shadow: 0 0 8px rgba(0,0,0,0.1); cursor: pointer; opacity: 0; transition: opacity 0.5s ease-in-out; } .images img.lazyloaded { opacity: 1; } #fullscreen-container { position: relative; } .counter-container { position: fixed; top: 10px; right: 10px; z-index: 10002; } .fancybox__counter { font-size: 16px; background: rgba(0, 0, 0, 0.6); color: #fff; padding: 4px 10px; border-radius: 12px; user-select: none; cursor: pointer; display: inline-block; } .fullscreen-container.jump-ui-active .counter-container { opacity: 0.2; pointer-events: none; } .fullscreen-viewer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; overflow: hidden; } .fullscreen-viewer.active { opacity: 1; visibility: visible; } .fullscreen-viewer img { max-width: 95%; max-height: 95%; object-fit: contain; cursor: grab; user-select: none; -webkit-user-drag: none; transition: opacity 0.2s ease-out;
      touch-action: none; /* Hammer가 제어 */
      transform-origin: center center;
      transition: none; /* transform transition 제거 (Hammer가 부드럽게 처리) */
     }
    .page-jump-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 10001; cursor: pointer; } #page-jump-list { background-color: #333; color: #eee; padding: 10px 0; border-radius: 10px; max-height: 70vh; overflow-y: auto; display: flex; flex-direction: column; gap: 0px; cursor: default; width: 200px; scrollbar-width: thin; scrollbar-color: #666 #333; } #page-jump-list::-webkit-scrollbar { width: 6px; } #page-jump-list::-webkit-scrollbar-track { background: #333; } #page-jump-list::-webkit-scrollbar-thumb { background-color: #666; border-radius: 3px; } .page-jump-number { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; cursor: pointer; font-weight: normal; text-align: left; transition: background-color 0.2s ease; border-bottom: 1px solid #444; font-size: 16px; } .page-jump-number:last-child { border-bottom: none; } .page-jump-number:hover { background-color: #444; } .page-jump-number::after { content: ''; display: inline-block; width: 18px; height: 18px; border-radius: 50%; border: 2px solid #888; margin-left: 15px; position: relative; box-sizing: border-box; } .page-jump-number.current { font-weight: bold; } .page-jump-number.current::after { border-color: #eee; background-color: #eee; }
  </style>
</head>
<body>
  <div class="info"> <h2 id="work-title"></h2> <p class="author" id="work-author"></p> </div>
  <div class="images"></div>
  <div id="load-more-trigger" style="height: 50px;"></div>
  <div id="fullscreen-container"></div>

  <script src="config.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

  <script> // 메인 뷰어 스크립트 시작
    if (typeof workConfig === 'undefined' || !workConfig || !Array.isArray(workConfig.images)) { /* 오류 처리 생략 */ throw new Error("workConfig is not defined..."); }

    const imageFiles = workConfig.images; const fullscreenContainer = document.getElementById('fullscreen-container'); const bodyElement = document.body; const imagesContainer = document.querySelector('.images'); const workTitleElement = document.getElementById('work-title'); const workAuthorElement = document.getElementById('work-author'); const loadMoreTrigger = document.getElementById('load-more-trigger');
    const itemsPerLoad = 10; let lastLoadedIndex = -1; let thumbnailObserver = null; let imageLazyLoadObserver = null;
    let currentIndex = 0; let isFullscreen = false; let fullscreenViewer = null; let viewerImage = null; let counterContainer = null; let counterElement = null; let pageJumpOverlay = null; const preloadCache = new Set();
    // --- Hammer.js 상태 변수 ---
    let currentScale = 1; let lastScale = 1; let translateX = 0, translateY = 0; let lastTranslateX = 0, lastTranslateY = 0; const minScale = 1, maxScale = 5;
    let hammerInstance = null;

    // --- 썸네일 관련 함수 (동일) ---
    function generateThumbnails(startIndex, count) { /* 내용 동일, 생략 */ const fragment = document.createDocumentFragment(); const endIndex = Math.min(startIndex + count, imageFiles.length); for (let index = startIndex; index < endIndex; index++) { if (index > lastLoadedIndex) { const filename = imageFiles[index]; if (!filename) continue; const link = document.createElement('a'); link.href = filename; link.dataset.index = index; const img = document.createElement('img'); img.dataset.src = filename; img.alt = `${workConfig.title || 'Image'} - Image ${index + 1}`; img.loading = 'lazy'; link.appendChild(img); fragment.appendChild(link); lastLoadedIndex = index; } } imagesContainer.appendChild(fragment); addViewerEventListeners(startIndex, endIndex); setupImageLazyLoadForRange(startIndex, endIndex); if (endIndex >= imageFiles.length && thumbnailObserver && loadMoreTrigger) { thumbnailObserver.unobserve(loadMoreTrigger); loadMoreTrigger.style.display = 'none'; } }
    function setupThumbnailObserver() { /* 내용 동일, 생략 */ const options = { root: null, rootMargin: '0px 0px 300px 0px', threshold: 0.01 }; thumbnailObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) generateThumbnails(lastLoadedIndex + 1, itemsPerLoad); }); }, options); if (loadMoreTrigger) thumbnailObserver.observe(loadMoreTrigger); else console.warn("Load more trigger element not found."); }
    function addViewerEventListeners(startIndex, endIndex) { /* 내용 동일, 생략 */ const links = imagesContainer.querySelectorAll(`a[data-index]:not([data-listener-added="true"])`); links.forEach(link => { const index = parseInt(link.dataset.index, 10); if (index >= startIndex && index < endIndex) { link.addEventListener('click', handleThumbnailClick); link.dataset.listenerAdded = 'true'; } }); }
    function handleThumbnailClick(event) { /* 내용 동일, 생략 */ event.preventDefault(); const index = parseInt(event.currentTarget.dataset.index, 10); if (!isNaN(index)) openFullscreen(index); else console.error("Invalid index on thumbnail click:", event.currentTarget); }
    function setupImageLazyLoadForRange(startIndex, endIndex) { /* 내용 동일, 생략 */ if (!imageLazyLoadObserver) { imageLazyLoadObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const lazyImage = entry.target; if (lazyImage.dataset.src) { lazyImage.src = lazyImage.dataset.src; lazyImage.classList.add('lazyloaded'); lazyImage.removeAttribute('data-src'); observer.unobserve(lazyImage); } } }); }, { rootMargin: '0px 0px 150px 0px' }); } const imagesToObserve = imagesContainer.querySelectorAll(`img[data-src]`); imagesToObserve.forEach(img => { const parentLink = img.closest('a'); if (parentLink && parentLink.dataset.index) { const index = parseInt(parentLink.dataset.index, 10); if (index >= startIndex && index < endIndex) imageLazyLoadObserver.observe(img); } }); }

    // --- 뷰어 공통 함수 ---
    function preloadImage(index) { /* 내용 동일, 생략 */ if (index < 0 || index >= imageFiles.length) return; const imageUrl = imageFiles[index]; if (!imageUrl || preloadCache.has(imageUrl)) return; const img = new Image(); img.src = imageUrl; preloadCache.add(imageUrl); }
    function updateCounter() { /* 내용 동일, 생략 */ if (counterElement) counterElement.innerText = `${currentIndex + 1} / ${imageFiles.length}`; }
    function showImage(index) { /* 내용 동일, 스케일/이동 초기화 */ if (!isFullscreen) return; if (index >= 0 && index < imageFiles.length) { currentIndex = index; const imageUrl = imageFiles[currentIndex]; if (!imageUrl) { console.error(`Image URL is invalid for index: ${index}`); return; } if (viewerImage) { currentScale = 1; lastScale = 1; translateX = 0; translateY = 0; lastTranslateX = 0; lastTranslateY = 0; applyTransform(); viewerImage.src = imageUrl; updateCounter(); preloadImage(currentIndex + 1); preloadImage(currentIndex - 1); } } else { console.warn(`Invalid index requested: ${index}`); } }
    function applyTransform() { // translate 와 scale 모두 적용
        if (viewerImage) {
            const { constrainedX, constrainedY } = constrainPanning(translateX, translateY, currentScale);
            viewerImage.style.transform = `translate(${constrainedX}px, ${constrainedY}px) scale(${currentScale})`;
        }
    }
    function constrainPanning(newX, newY, scale) { /* 내용 동일, 생략 */ if (!viewerImage || scale <= 1) return { constrainedX: 0, constrainedY: 0 }; const naturalWidth = viewerImage.offsetWidth; const naturalHeight = viewerImage.offsetHeight; if (naturalWidth === 0 || naturalHeight === 0) return { constrainedX: 0, constrainedY: 0 }; const scaledWidth = naturalWidth * scale; const scaledHeight = naturalHeight * scale; const maxX = Math.max(0, (scaledWidth - window.innerWidth) / 2); const minX = -maxX; const maxY = Math.max(0, (scaledHeight - window.innerHeight) / 2); const minY = -maxY; const constrainedX = Math.max(minX, Math.min(maxX, newX)); const constrainedY = Math.max(minY, Math.min(maxY, newY)); return { constrainedX, constrainedY }; }
    function togglePageJumpUI() { /* 내용 동일, 생략 */ if (!isFullscreen) return; if (pageJumpOverlay) { removePageJumpUI(); return; } pageJumpOverlay = document.createElement('div'); pageJumpOverlay.className = 'page-jump-overlay'; pageJumpOverlay.addEventListener('click', handleOverlayClick); createPageJumpList(pageJumpOverlay); fullscreenContainer.appendChild(pageJumpOverlay); fullscreenContainer.classList.add('jump-ui-active'); const currentButton = pageJumpOverlay.querySelector(`.page-jump-number.current`); if (currentButton) currentButton.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
    function handleOverlayClick(event) { /* 내용 동일, 생략 */ if (event.target === pageJumpOverlay) removePageJumpUI(); }
    function createPageJumpList(overlay) { /* 내용 동일, 생략 */ const listContainer = document.createElement('div'); listContainer.id = 'page-jump-list'; listContainer.addEventListener('click', (e) => e.stopPropagation()); for (let i = 1; i <= imageFiles.length; i++) { const pageNumElement = document.createElement('div'); pageNumElement.className = 'page-jump-number'; pageNumElement.innerHTML = `<span>${i}</span>`; pageNumElement.dataset.page = i; if (i === currentIndex + 1) pageNumElement.classList.add('current'); pageNumElement.addEventListener('click', handleJumpNumberClick); listContainer.appendChild(pageNumElement); } overlay.appendChild(listContainer); }
    function handleJumpNumberClick(event) { /* 내용 동일, 생략 */ const targetPage = parseInt(event.currentTarget.dataset.page, 10); if (!isNaN(targetPage)) { showImage(targetPage - 1); removePageJumpUI(); } }
    function removePageJumpUI() { /* 내용 동일, 생략 */ if (pageJumpOverlay) { pageJumpOverlay.remove(); pageJumpOverlay = null; } fullscreenContainer.classList.remove('jump-ui-active'); }

    // --- ★★★ Hammer.js 이벤트 핸들러 ★★★ ---
    function handlePinchStart(ev) {
        console.log("Hammer: Pinch Start");
        lastScale = currentScale;
        // 줌 중심 패닝을 위해 초기 이동값 저장 (더 자연스러운 줌 효과)
        lastTranslateX = translateX;
        lastTranslateY = translateY;
        // (줌 중심점 계산은 복잡하므로 여기서는 생략, 필요시 추가)
    }
    function handlePinchMove(ev) {
        // console.log("Hammer: Pinch Move, Scale:", ev.scale);
        let newScale = lastScale * ev.scale;
        newScale = Math.max(minScale, Math.min(maxScale, newScale));
        currentScale = newScale;
        // (줌 중심점 계산 및 translateX/Y 업데이트 로직 추가 필요)
        applyTransform(); // 현재는 중앙 줌만 적용됨
    }
    function handlePinchEnd(ev) {
        console.log("Hammer: Pinch End, Final Scale:", currentScale);
        lastScale = currentScale;
        if (currentScale <= 1) { // 1 이하로 축소 시 리셋
            currentScale = 1; lastScale = 1;
            translateX = 0; translateY = 0;
            lastTranslateX = 0; lastTranslateY = 0;
            applyTransform();
        }
    }
    function handlePanStart(ev) {
         if (currentScale <= 1) return; // 확대 안됐으면 패닝 무시
         console.log("Hammer: Pan Start");
         lastTranslateX = translateX;
         lastTranslateY = translateY;
    }
    function handlePanMove(ev) {
        if (currentScale <= 1) return; // 확대 안됐으면 패닝 무시
        // console.log("Hammer: Pan Move, DeltaX:", ev.deltaX, "DeltaY:", ev.deltaY);
        translateX = lastTranslateX + ev.deltaX;
        translateY = lastTranslateY + ev.deltaY;
        applyTransform(); // 이동 적용 (constrainPanning 내부에서 처리)
    }
    function handlePanEnd(ev) {
        if (currentScale <= 1) return; // 확대 안됐으면 패닝 무시
        console.log("Hammer: Pan End");
        // 마지막 위치는 applyTransform 내에서 이미 lastTranslateX/Y에 저장됨
    }
    function handleTap(ev) {
        // 확대 상태가 아닐 때만 다음 이미지로
        if (currentScale <= 1 && !pageJumpOverlay) {
             console.log("Hammer: Tap Detected (Next Image)");
             nextImage();
        } else {
             console.log("Hammer: Tap Ignored (Zoomed or Jump UI active)");
        }
    }
    function handleSwipe(ev) {
        // 확대 상태가 아닐 때만 이전/다음 이미지로
        if (currentScale <= 1 && !pageJumpOverlay) {
            if (ev.direction === Hammer.DIRECTION_LEFT) {
                console.log("Hammer: Swipe Left (Next Image)");
                nextImage();
            } else if (ev.direction === Hammer.DIRECTION_RIGHT) {
                console.log("Hammer: Swipe Right (Prev Image)");
                prevImage();
            }
        } else {
            console.log("Hammer: Swipe Ignored (Zoomed or Jump UI active)");
        }
    }

    // --- 뷰어 열기/닫기, 이미지 넘김, 키보드 이벤트 함수 ---
    function openFullscreen(index) {
        if (isFullscreen) return; currentIndex = index; isFullscreen = true; const imageUrl = imageFiles[currentIndex]; if (!imageUrl) { console.error("Invalid image index:", index); isFullscreen = false; return; } bodyElement.classList.add('fullscreen-active'); fullscreenViewer = document.createElement('div'); fullscreenViewer.classList.add('fullscreen-viewer'); fullscreenViewer.innerHTML = `<img src="${imageUrl}" alt="${workConfig.title || 'Image'} - Image ${currentIndex + 1}">`; viewerImage = fullscreenViewer.querySelector('img');
        viewerImage.onload = () => { preloadImage(currentIndex + 1); preloadImage(currentIndex - 1); }; viewerImage.onerror = () => { console.error("Failed load:", imageUrl); viewerImage.alt="이미지 로드 실패"; };
        // 배경 클릭 시 닫기는 Hammer tap 핸들러에서 간접적으로 처리 (확대 안됐을 때)
        // fullscreenViewer.addEventListener('click', handleViewerClick); // 제거

        counterContainer = document.createElement('div'); counterContainer.className = 'counter-container'; counterElement = document.createElement("div"); counterElement.className = "fancybox__counter"; counterElement.addEventListener('click', togglePageJumpUI); counterContainer.appendChild(counterElement);
        fullscreenContainer.appendChild(fullscreenViewer); fullscreenContainer.appendChild(counterContainer); updateCounter(); document.addEventListener('keydown', handleKeydown);

        // ▼▼▼ Hammer.js 초기화 (모든 제스처 활성화) ▼▼▼
        hammerInstance = new Hammer(fullscreenViewer, { // 뷰어 전체 영역에 적용
             recognizers: [
                 [Hammer.Pinch, { enable: true }],
                 // Pan은 Pinch와 동시에 인식되도록 설정 (recognizeWith)
                 [Hammer.Pan, { enable: true, direction: Hammer.DIRECTION_ALL }],
                 [Hammer.Swipe, { enable: true, direction: Hammer.DIRECTION_HORIZONTAL }], // 수평 스와이프만
                 [Hammer.Tap, { enable: true, taps: 1, event: 'tap' }] // 싱글 탭
             ]
        });
        // Pinch와 Pan 동시 인식 허용 (줌하면서 패닝 가능하도록)
        hammerInstance.get('pinch').recognizeWith(hammerInstance.get('pan'));

        hammerInstance.on('pinchstart', handlePinchStart);
        hammerInstance.on('pinchmove', handlePinchMove);
        hammerInstance.on('pinchend pinchcancel', handlePinchEnd); // 종료 및 취소
        hammerInstance.on('panstart', handlePanStart);
        hammerInstance.on('panmove', handlePanMove);
        hammerInstance.on('panend pancancel', handlePanEnd); // 종료 및 취소
        hammerInstance.on('tap', handleTap);
        hammerInstance.on('swipeleft', handleSwipe);
        hammerInstance.on('swiperight', handleSwipe);
        console.log("Hammer.js initialized for ALL gestures");
        // ▲▲▲ Hammer.js 초기화 ▲▲▲

        requestAnimationFrame(() => { if (fullscreenViewer) fullscreenViewer.classList.add('active'); });
    }
    // handleViewerClick 함수 제거

    function closeFullscreen() {
        if (!isFullscreen) return; isFullscreen = false; removePageJumpUI(); bodyElement.classList.remove('fullscreen-active');
        // ▼▼▼ Hammer.js 인스턴스 제거 ▼▼▼
        if (hammerInstance) { hammerInstance.destroy(); hammerInstance = null; console.log("Hammer.js instance destroyed"); }
        // ▲▲▲ Hammer.js 인스턴스 제거 ▲▲▲
        // 직접 추가한 리스너는 없으므로 제거 불필요
        if (counterElement) counterElement.removeEventListener('click', togglePageJumpUI); document.removeEventListener('keydown', handleKeydown);
        if (thumbnailObserver) thumbnailObserver.disconnect(); if (imageLazyLoadObserver) imageLazyLoadObserver.disconnect(); thumbnailObserver = null; imageLazyLoadObserver = null;
        if (fullscreenViewer) fullscreenViewer.classList.remove('active');
        setTimeout(() => { fullscreenContainer.innerHTML = ''; fullscreenViewer = null; viewerImage = null; counterContainer = null; counterElement = null; pageJumpOverlay = null;
             currentScale = 1; lastScale = 1; translateX = 0; translateY = 0; lastTranslateX = 0; lastTranslateY = 0; preloadCache.clear(); }, 300);
    }
    function nextImage() { /* 내용 동일, 생략 */ if (isFullscreen && !pageJumpOverlay && currentScale <= 1) showImage((currentIndex + 1) % imageFiles.length); }
    function prevImage() { /* 내용 동일, 생략 */ if (isFullscreen && !pageJumpOverlay && currentScale <= 1) showImage((currentIndex - 1 + imageFiles.length) % imageFiles.length); }
    function handleKeydown(event) { /* 내용 동일, 생략 */ if (pageJumpOverlay) { if (event.key === 'Escape') removePageJumpUI(); return; } if (isFullscreen) { if (event.key === 'Escape') closeFullscreen(); } }

    // --- 초기화 ---
    document.addEventListener('DOMContentLoaded', () => { /* 내용 동일, 생략 */ if (typeof workConfig !== 'undefined') { document.title = workConfig.title || "작품 뷰어"; if (workTitleElement) workTitleElement.textContent = workConfig.title || "제목 없음"; if (workAuthorElement) workAuthorElement.textContent = `작가: ${workConfig.author || "작자 미상"}`; generateThumbnails(0, itemsPerLoad); setupThumbnailObserver(); } else { console.error("Initialization failed because workConfig is not defined."); } });
  </script>
</body>
</html>